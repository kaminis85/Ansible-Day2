---
# Trident protect common tasks for both Backup/Restore and Snapshot/Restore scenarios

# Verify Trident Protect installation
- name: Check if trident-protect namespace exists
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig_path }}"
    kind: Namespace
    name: trident-protect
  register: tp_namespace_check
  failed_when: tp_namespace_check.resources | length == 0
  tags:
    - tp_prerequisites

- name: Verify Trident Protect is installed (check controller manager deployment)
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig_path }}"
    kind: Deployment
    namespace: trident-protect
    name: trident-protect-controller-manager
  register: tp_deployment_check
  failed_when: tp_deployment_check.resources | length == 0
  tags:
    - tp_prerequisites

# Create Kubernetes Secret to store ONTAP S3 credentials
- name: Create Kubernetes Secret to store ONTAP S3 credentials
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    namespace: trident-protect   # Must be in the Trident protect namespace
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: "{{ appvault_secret_name }}"   # Name of your secret
      type: Opaque
      stringData:
        accessKeyID: "{{ s3_access_key }}"
        secretAccessKey: "{{ s3_secret_key }}"
  when: appvault_secret_name is defined and s3_access_key is defined and s3_secret_key is defined
  tags:
    - s3_secret_create

# Create Trident protect AppVault for ONTAP S3
- name: Create Trident protect AppVault for ONTAP S3
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    namespace: trident-protect   # Must be in the Trident protect namespace
    definition:
      apiVersion: protect.trident.netapp.io/v1
      kind: AppVault
      metadata:
        name: "{{ appvault_name }}"   # Name of your AppVault
      spec:
        providerType: "OntapS3"
        providerConfig:
          s3:
            bucketName: "{{ ontap_s3_bucket_name }}"
            endpoint: "{{ ontap_s3_endpoint }}"
            secure: "false"
            skipCertValidation: "true"
        providerCredentials:
          accessKeyID:
            valueFromSecret:
              name: "{{ appvault_secret_name }}"   # Name of the S3 secret created earlier
              key: accessKeyID
          secretAccessKey:
            valueFromSecret:
              name: "{{ appvault_secret_name }}"
              key: secretAccessKey
  when: appvault_name is defined and ontap_s3_bucket_name is defined and ontap_s3_endpoint is defined and appvault_secret_name is defined
  tags:
    - tp_create_appvault

# View the newly created AppVault object
- name: Verify AppVault creation
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig_path }}"
    kind: AppVault
    api_version: protect.trident.netapp.io/v1
    namespace: trident-protect
    name: "{{ appvault_name }}"
  register: appvault_output
  when: appvault_name is defined
  tags:
    - tp_verify_appvault

- name: Display AppVault details
  ansible.builtin.debug:
    var: appvault_output.resources[0]
  when: appvault_name is defined and appvault_output.resources | length > 0
  tags:
    - tp_verify_appvault

# Check if VM namespace exists before labeling
- name: Check if {{ vm_namespace }} namespace exists
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig_path }}"
    kind: Namespace
    name: "{{ vm_namespace }}"
  register: vm_namespace_check
  failed_when: vm_namespace_check.resources | length == 0
  when: vm_namespace is defined
  tags:
    - oc_label_vms_and_pvcs

# Label specific VMs and their associated resources (PVCs) in a namespace 
- name: Label specific VMs and their PVCs in {{ vm_namespace }} namespace
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    namespace: "{{ vm_namespace }}"
    kind: "{{ item.kind }}"
    name: "{{ item.name }}"
    merge_type: strategic-merge
    definition:
      metadata:
        labels:
          category: "{{ vm_label }}"
  loop: "{{ (vm_list | map('community.general.dict_kv', 'kind', 'VirtualMachine') | list) + (pvc_list | map('community.general.dict_kv', 'kind', 'PersistentVolumeClaim') | list) }}"
  when: (vm_list is defined and vm_list | length > 0) or (pvc_list is defined and pvc_list | length > 0)
  tags:
    - oc_label_vms_and_pvcs

# Verify that the VMs and their corresponding PVCs got the labels
- name: Verify labels for VMs and their PVCs in {{ vm_namespace }} namespace
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig_path }}"
    kind: "{{ item.kind }}"
    namespace: "{{ vm_namespace }}"
    name: "{{ item.name }}"
  loop: "{{ (vm_list | map('community.general.dict_kv', 'kind', 'VirtualMachine') | list) + (pvc_list | map('community.general.dict_kv', 'kind', 'PersistentVolumeClaim') | list) }}"
  register: label_info
  when: (vm_list is defined and vm_list | length > 0) or (pvc_list is defined and pvc_list | length > 0)
  tags:
    - oc_verify_vms_and_pvcs_labels

- name: Display label information for VMs and their PVCs
  ansible.builtin.debug:
    msg: "{{ item.resources[0].metadata.labels }}"
  loop: "{{ label_info.results }}"
  when: 
    - (vm_list is defined and vm_list | length > 0) or (pvc_list is defined and pvc_list | length > 0)
    - label_info is defined
  tags:
    - oc_verify_vms_and_pvcs_labels

# Create an application for specific VMs using the label selector
- name: Create an application in {{ vm_namespace }} namespace for specific VMs using the label selector
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    namespace: "{{ vm_namespace }}"
    definition:
      apiVersion: protect.trident.netapp.io/v1
      kind: Application
      metadata:
        name: "{{ application_name }}"   # Application name for the VMs
      spec:
        includedNamespaces:
          - namespace: "{{ vm_namespace }}"
            labelSelector:
              matchLabels:
                category: "{{ vm_label }}"
  when: application_name is defined
  tags:
    - tp_create_application

# Verify the newly created application in the specified namespace
- name: Execute tridentctl-protect get application command to verify application creation
  ansible.builtin.command:
    cmd: tridentctl-protect get application "{{ application_name }}" -n "{{ vm_namespace }}"
  register: application_output
  changed_when: false
  when: application_name is defined
  tags:
    - tp_verify_application

- name: Display Application details created in {{ vm_namespace }} namespace
  ansible.builtin.debug:
    msg: "{{ application_output.stdout_lines }}"
  when: application_name is defined and application_output is defined
  tags:
    - tp_verify_application

# End of Trident protect common tasks